// spatial filter - minimum area
// dhemerson.costa@ipam.org.br

// define root
var root = 'users/dh-conciani/collection7/c7-general-post/';

// define input file 
var file_in = 'CERRADO_col7_gapfill_incidence_temporal_frequency_geomorfology_v8';

// define output version 
var version_out = 8;

// read image
var classification = ee.Image(root + file_in);

// define minimum mapeable area
var filter_size = 6;

// import mapbiomas color ramp
var vis = {
      min:0,
      max:49,
      palette: require('users/mapbiomas/modules:Palettes.js').get('classification6'),
    };

// plot  input version
Map.addLayer(classification.select(['classification_2010']), vis, 'input 2010');


// create an empty recipe
var filtered = ee.Image([]);

// apply filter
ee.List.sequence({'start': 1985, 'end': 2021}).getInfo()
      .forEach(function(year_i) {
        // compute the focal model
        var focal_mode = classification.select(['classification_' + year_i])
                .unmask(0)
                .focal_mode({'radius': 1, 'kernelType': 'square', 'units': 'pixels'});
 
        // compute te number of connections
        var connections = classification.select(['classification_' + year_i])
                .unmask(0)
                .connectedPixelCount({'maxSize': 100, 'eightConnected': false});
        
        // get the focal model when the number of connections of same class is lower than parameter
        var to_mask = focal_mode.updateMask(connections.lte(filter_size));

        // apply filter
        var classification_i = classification.select(['classification_' + year_i])
                .blend(to_mask)
                .reproject('EPSG:4326', null, 30);

        // stack into recipe
        filtered = filtered.addBands(classification_i.updateMask(classification_i.neq(0)));
        }
      );

// print filtered
Map.addLayer(filtered.select(['classification_2010']), vis, 'filtered 2010 - round 1');

// set recipe 
var recipe = ee.Image([]);

// apply filter
ee.List.sequence({'start': 1985, 'end': 2021}).getInfo()
      .forEach(function(year_i) {
        // compute the focal model
        var focal_mode = filtered.select(['classification_' + year_i])
                .unmask(0)
                .focal_mode({'radius': 1, 'kernelType': 'square', 'units': 'pixels'});
 
        // compute te number of connections
        var connections = filtered.select(['classification_' + year_i])
                .unmask(0)
                .connectedPixelCount({'maxSize': 100, 'eightConnected': false});
        
        // get the focal model when the number of connections of same class is lower than parameter
        var to_mask = focal_mode.updateMask(connections.lte(filter_size));

        // apply filter
        var classification_i = filtered.select(['classification_' + year_i])
                .blend(to_mask)
                .reproject('EPSG:4326', null, 30);

        // stack into recipe
        recipe = recipe.addBands(classification_i.updateMask(classification_i.neq(0)));
        }
      );

Map.addLayer(recipe.select(['classification_2010']), vis, 'filtered 2010 - round 2');

// create recipe 
var recipe2 = ee.Image([]);

// fill zeros (blank spaces generated by regions register)
ee.List.sequence({'start': 1985, 'end': 2021}).getInfo()
  .forEach(function(year_i) {
    // compute the focal mode with an extended kernel
    var focal_mode =  recipe.select(['classification_' + year_i])
                .unmask(0)
                .focal_mode({'radius': 4, 'kernelType': 'square', 'units': 'pixels'});
                
    // get only blank pixels (value equals to zero) 
    var to_mask = focal_mode.updateMask(recipe.select(['classification_2010']).unmask(0).eq(0));
    
    // apply filter
    var classification_i = recipe.select(['classification_' + '2010'])
                .blend(to_mask)
                .reproject('EPSG:4326', null, 30);
    
    // stack into recipe
    recipe2 = recipe2.addBands(classification_i.updateMask(classification_i.neq(0)));
  });

Map.addLayer(recipe2.select(['classification_2010']), vis, 'final filled');

// export as GEE asset
Export.image.toAsset({
    'image': recipe,
    'description': 'CERRADO_col7_gapfill_incidence_temporal_frequency_geomorfology_spatial_v' + version_out,
    'assetId': root + 'CERRADO_col7_gapfill_incidence_temporal_frequency_geomorfology_spatial_v' + version_out,
    'pyramidingPolicy': {
        '.default': 'mode'
    },
    'region': classification.geometry(),
    'scale': 30,
    'maxPixels': 1e13
});
