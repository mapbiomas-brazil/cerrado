// Create and export auxiliary data mosaics ("slope", "textG", "latitude", "longitude" and "year") as GEE assets
// For clarification, write to <dhemerson.costa@ipam.org.br> and <felipe.lenti@ipam.org.br>

// define strings to be used as metadata
var bioma = "CERRADO";    // biome
var versao = '1';         // version string

// define output directory
var dirOut = 'projects/mapbiomas-workspace/AMOSTRAS/Cerrado/col6/auxMosaics/';  

// define surface reflectance mosaic - collection 6.0
// landsat 5
var dirasset = 'projects/nexgenmap/MapBiomas2/LANDSAT/mosaics';
// landsat 7
var dirassetL7 = 'projects/nexgenmap/MapBiomas2/LANDSAT/mosaics-landsat-7';

// import biomes
var biomes = ee.Image('projects/mapbiomas-workspace/AUXILIAR/biomas-2019-raster');
// select only cerrado biome and mask anothers
var bioma250mil_CE = biomes.mask(biomes.eq(4)).aside(Map.addLayer);

// import classification regions
var regioesCollection = ee.FeatureCollection('projects/mapbiomas-workspace/AUXILIAR/CERRADO/cerrado_regioes_c6');

// import sample points (generated by step 3)
var pts = ee.FeatureCollection('projects/mapbiomas-workspace/AMOSTRAS/Cerrado/col6/samples/samples_col6_CERRADO_v1');

// import terrain model and compute slope (from ALOS AW3D30) 
var slope = ee.Terrain.slope(ee.Image("JAXA/ALOS/AW3D30_V1_1").select("AVE")).rename("slope");

// define the kernel parameter to be used in entropy's computation  
var square = ee.Kernel.square({radius: 5}); 

// define regions to create auxiliary data (spatial operator)
var regioes_lista = [  //[13], [16], [21], [23], [24], [26], [34] // test dataset - collection 6.0
  
                       [1], [2], [3], [4], [5], [6], [7],
                       [8], [9], [10], [11], [12], [13], [14],
                       [15], [16], [17], [18], [19], [20], [21],
                       [22], [23], [24], [25], [26], [27], [28],
                       [29], [30], [31], [32], [33], [34], [35],
                       [36], [37], [38]
                       ];

// define years to create auxiliary data (temporal operator)
var anos = [  
            1985, 1986, 1987, 1988, 1989,
            1990, 1991, 1992, 1993, 1994,
            1995, 1996, 1997, 1998, 1999,
            2000, 2001, 2002, 2003, 2004,
            2005, 2006, 2007, 2008, 2009,
            2010, 2011, 2012, 2013, 2014, 
            2015, 2016, 2017, 2018, 2019, 2020
];

// define the list of input bandnames (from SR mosaics) to be used as function operators
var bandNames = ee.List([
  "ndvi_median_dry",
  "ndvi_median_wet",
  "green_median",
  ]);

// define the list of output bandnames (from aux) to be used as function operators 
var outputs = ee.List([
  "slope",
  'textG',
  'latitude',
  'longitude'
  ]);
  
// import palette module from mapbiomas
var palettes = require('users/mapbiomas/modules:Palettes.js');
var vis = {
    'min': 0,
    'max': 49,
    'palette': palettes.get('classification6')
};

// create an empty spatial recipe 
var colecReg = ee.FeatureCollection([]);

// define function to build auxiliare mosaic 
// call each region in 'regioes_lista', and store in 'regiao' by 'lista' 
regioes_lista.forEach(function(lista){
  var regiao = lista[0];

  // nested function - for each region, read each value in 'anos' and store in 'ano'
  anos.forEach(function(ano){
    // subset region  
    var limite = regioesCollection.filterMetadata('mapb', "equals", regiao).geometry().bounds();
    // import mosaic
    var mosaicoCer;  // define a empty variable to be used in conditional decision
    // when year is different of 2002 and 2012, use Landsat 5 (TM) and Landsat 8 imagery
    if (ano !== 2012 && ano !== 2002) {
      mosaicoCer = ee.ImageCollection(dirasset)
                   .filterMetadata('biome', 'equals', bioma)
                   .select(bandNames);
    } else {
    // when year is equal to 2002 and 2012, use Landsat 7 (ETM+) imagery
        mosaicoCer = ee.ImageCollection(dirassetL7)
                     .filterMetadata('biome', 'equals', bioma)
                     .select(bandNames);
    }
    // read yearly mosaic 
    var mosaicoTotal = mosaicoCer
                       .filterMetadata('year', 'equals', (ano))
                       .filterBounds(limite)
                       .mosaic();
    // create previous one and previous two year mosaics to be use in amplitude computation
    var mosaico1ano_antes;  // define a empty variable to be used in conditional decision
    var mosaico2anos_antes; // define a empty variable to be used in conditional decision
    // when year is different of 2013, 2014, 2003 or 2004, use TM and OLI asset for both one or two past years
    if (ano !== 2013 || ano !== 2014 || ano !== 2003 || ano !== 2004) {
    mosaico1ano_antes = mosaicoCer
                        .filterMetadata('year', 'equals', ( ano - 1))
                        .filterBounds(limite)
                        .mosaic()
                        .select(['ndvi_median_dry','ndvi_median_wet']);
  
    mosaico2anos_antes = mosaicoCer
                        .filterMetadata('year', 'equals', ( ano - 2))
                        .filterBounds(limite)
                        .mosaic()
                        .select(['ndvi_median_dry','ndvi_median_wet']);
                        print (ano);
    }
    // when year equal to 2013 or 2003, use ETM+ for past one year and TM/OLI for past two years
    if (ano === 2013 || ano === 2003) {
      var mosaic_L7 = ee.ImageCollection(dirassetL7)
                     .filterMetadata('biome', 'equals', bioma)
                     .select(bandNames);
                     
      mosaico1ano_antes = mosaic_L7
                        .filterMetadata('year', 'equals', ( ano - 1))
                        .filterBounds(limite)
                        .mosaic()
                        .select(['ndvi_median_dry','ndvi_median_wet']);
                        
                        mosaico2anos_antes = mosaicoCer
                        .filterMetadata('year', 'equals', ( ano - 2))
                        .filterBounds(limite)
                        .mosaic()
                        .select(['ndvi_median_dry','ndvi_median_wet']);
    }
    // when year equal to 2014 or 2004, use TM/OLI for past one year and ETM+ for past two years
    if (ano === 2014 || ano === 2004) {
      var mosaic_L7 = ee.ImageCollection(dirassetL7)
                     .filterMetadata('biome', 'equals', bioma)
                     .select(bandNames);
                     
      mosaico1ano_antes = mosaicoCer
                        .filterMetadata('year', 'equals', ( ano - 1))
                        .filterBounds(limite)
                        .mosaic()
                        .select(['ndvi_median_dry','ndvi_median_wet']);
                        
                        mosaico2anos_antes = mosaic_L7
                        .filterMetadata('year', 'equals', ( ano - 2))
                        .filterBounds(limite)
                        .mosaic()
                        .select(['ndvi_median_dry','ndvi_median_wet']);
    }
    // compute minimum NDVI considering the current year and the past two years
    var min3anos = ee.ImageCollection.fromImages([mosaicoTotal.select('ndvi_median_dry'),
                                                  mosaico1ano_antes.select('ndvi_median_dry'),
                                                  mosaico2anos_antes.select('ndvi_median_dry')]).min();
    // compute maximum NDVI considering the current year and the past two years
    var max3anos = ee.ImageCollection.fromImages([mosaicoTotal.select('ndvi_median_wet'),
                                                  mosaico1ano_antes.select('ndvi_median_wet'),
                                                  mosaico2anos_antes.select('ndvi_median_wet')]).max();
    // compute NDVI amplitude by subtracting maximum value from minimum value
    var amp3anos = max3anos.subtract(min3anos).rename('amp_ndvi_3anos');
    // create a longitude and latitude image considering the cerrado biome extent
    var ll = ee.Image.pixelLonLat().mask(bioma250mil_CE);
    // compute longitude and latitude values 
    var long = ll.select('longitude').add(34.8).multiply(-1).multiply(1000).toInt16();
    var lati = ll.select('latitude').add(5).multiply(-1).multiply(1000).toInt16();
    // compute entropy 
    var entropyG = mosaicoTotal.select('green_median').entropy(square);
    
    // when years is less than 1987, NDVI amplitude is not avaliable, for this reason, use a null image  
    if (ano < 1987){
       amp3anos = ee.Image(0).rename('amp_ndvi_3anos');
    }
    // create multi-band auxiliary data mosaic 
    var mosaicoOut = amp3anos.addBands(long.rename('longitude'))
                             .addBands(lati.rename('latitude' ))
                             .addBands(entropyG.select([0],['textG']).multiply(100).int16())
                             .addBands(slope.int8().clip(limite));
        mosaicoOut = ee.Image(mosaicoOut.setMulti({"year":ano, "mapb": regiao }));                     
     print(mosaicoOut);
    
    // create label to be used in auxiliary data exportation 
    var label ='aux_col_6_reg_' + regiao + "_ano_" + ano;
    // plot mosaic - need visualization parameters
    Map.addLayer(mosaicoOut.randomVisualizer(), {}, 'mosaico', false);
    // export auxiliary data 
    Export.image.toAsset({image:mosaicoOut,
                          description:label,
                          assetId:dirOut+label,
                          region:limite,
                          scale:30,
                          maxPixels:1e13
                          });
    });
});
